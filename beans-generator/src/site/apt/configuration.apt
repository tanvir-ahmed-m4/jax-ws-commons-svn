                    ----
                    Configuration
                    ----
                    Fedor Malyshkin
                    ----
                    05-07-2007
                    ----

Configuration

        [Note:] This tool could be used only for JAX-WS web-services which was deployed as servlet in a servlet containers.

    For use this tool you need to copy beans-generator and {{{http://asm.objectweb.org}asm 3.0}} jars into 
    WEB-INF's lib folder and add tools-specific listeners into web.xml. 

------------------
<listener>
    <listener-class>org.jvnet.jax_ws_commons.beans_generator.servlet.jaxws.WSServletContextListenerWrapper</listener-class>
</listener>


<listener>
    <listener-class>org.jvnet.jax_ws_commons.beans_generator.servlet.jaxws.RequestClassLoaderSubstituter</listener-class>
</listener>
------------------  
    
     It releases you from generating web-service artifacts, but configuration process of web application stays the same: 
you must supply <<<"sun-jaxws.xml">>> for JAXWS WS stack.
        
    But you can use additional features like creating your own class which can processes all web-service requests and decides 
what to with them: invoke a implementator, change request parameters, change response or do something other. For this you 
must change <<<"sun-jaxws.xml">>> like this:

    From this:

---------------
<endpoints xmlns="http://java.sun.com/xml/ns/jax-ws/ri/runtime" version="2.0">
    <endpoint name="Em" implementation="ru.magnetosoft.magnet.subsystem.context.ContextStaticTest" 
url-pattern="/Em"  /> 
</endpoints>
---------------

    to this:

---------------
<endpoints xmlns="http://java.sun.com/xml/ns/jax-ws/ri/runtime" version="2.0">
    <endpoint name="Em" implementation="ru.magnetosoft.magnet.subsystem.context.ContextStaticTestNew" 
url-pattern="/Em"  wrappedClass="ru.magnetosoft.magnet.subsystem.context.ContextStaticTest" 
implementationInvoker="ru.magnetosoft.magnet.subsystem.context.invoker.ImplementationInvoker"/> 
</endpoints>
--------------

    In that case <<<"implementation">>> class must differs from <<<"wrappedClass">>>. It will be generated by the tool and
    will repeat all methods and annotations of <<<"wrappedClass">>> (original class). It packs method name, thrown types,
    parameter types, parameter values, return type and invokes <<<"implementationInvoker">>> with all these datas. 
    After this it waites for result it returns to JAXWS stack. 
    
    In our firm we are using this approach in specific manner which described in {{{usages.html}Usages}}.

    You must supply your implementator invoker class and it must implements a interface IImplementationInvoker. 
    It gets all parameters in <<<initialize>>> method and processes all requests with help a <<<invoke>>> method.
    Example:


+----------------------------------------------------------------------------------+
package org.jvnet.jax_ws_commons.beans_generator.invoker;

import java.io.ByteArrayOutputStream;
import java.io.PrintWriter;
import java.lang.reflect.Method;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.jvnet.jax_ws_commons.beans_generator.conf.IDeploymentConfigurationReader;


/**
 * Class, directly invocable from ambassador.
 * Servers as dispather for all invocations of ws implementator. Simplest realization 
 * could simple invoke implementation, more sophisticated - make a lot of things.
 * 
 * Created: 04.06.2007
 * @author Malyshkin Fedor (fedor.malyshkin@magnetosoft.ru)
 * @version $Revision: 240 $
 */
public class ImplementationInvoker implements IImplementationInvoker {
    private IDeploymentConfigurationReader configReader = null;

    private String implClassName = null;

    private Class implClass = null;

    private Object impl = null;

    private Logger log = null;

    public void initialize(IDeploymentConfigurationReader configReader,
        String implementationClassName) {
    this.configReader = configReader;
    this.implClassName = implementationClassName;
    this.log = Logger.getLogger(implementationClassName);
    }

    public Object invoke(String methodName, Class returnClass,
        Class[] argumentClasses, Class[] thrownTypes, Object returnValue,
        Object[] argumentValues) throws Exception {

    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    PrintWriter pw = new PrintWriter(baos);
    pw.println("Invoking method: " + methodName);

    pw.println(">>> args count: " + argumentClasses.length);
    pw.println(">>> arg classes: ");
    for (Class clazz : argumentClasses)
        pw.print(clazz.getSimpleName() + " ");
    pw.println();

    pw.println(">>> arg value: ");
    for (Object arg : argumentValues)
        pw.print((arg != null ? arg.toString() : "null") + " ");
    pw.println();

    pw.println(">>> return type: " + returnClass.getSimpleName());

    pw.println(">>> thrown types count: " + thrownTypes.length);
    pw.println(">>> thrown type classes: ");
    for (Class clazz : thrownTypes)
        pw.print(clazz.getSimpleName() + " ");
    pw.println();

    pw.flush();
    log.info(baos.toString());

    returnValue = invokeImplementation(methodName, returnClass, argumentClasses, thrownTypes, returnValue, argumentValues);

    log.info("Result: " + (returnValue != null ? returnValue.toString() : "null"));
    return returnValue;
    }

    /**
     * @param methodName
     * @param returnClass
     * @param argumentClasses
     * @param thrownTypes
     * @param returnValue
     * @param argumentValues
     */
    protected Object invokeImplementation(String methodName, Class returnClass,
        Class[] argumentClasses, Class[] thrownTypes, Object returnValue,
        Object[] argumentValues) throws Exception {

    // we create new array of args because we added on additional arg - String
    Class[] realArguments = new Class[argumentClasses.length - 1];
    System.arraycopy(argumentClasses, 0, realArguments, 0, argumentClasses.length - 1);
    Method method = null;

    try {
        method = getMethod(methodName, realArguments);
    } catch (Exception e) {
        log.log(Level.SEVERE, "Exception while getting implementator's method", e);
    }

    // do the same thing with arg values
    Object[] realArgValues = new Object[argumentValues.length - 1];
    System.arraycopy(argumentValues, 0, realArgValues, 0, argumentClasses.length - 1);
    //try {
    returnValue = method.invoke(getImplementationInstance(), realArgValues);
    //} catch (Exception e) {
    //log.log(Level.SEVERE, "Exception while invoking implementator", e);
    //}

    return returnValue;
    }

    /**
     * @param methodName
     * @param realArguments
     * @return
     * @throws NoSuchMethodException 
     * @throws SecurityException 
     * @throws ClassNotFoundException 
     */
    protected Method getMethod(String methodName, Class[] realArguments)
        throws SecurityException, NoSuchMethodException,
        ClassNotFoundException {
    if (implClass == null)
        implClass = getImplementationClass(implClassName);
    return implClass.getMethod(methodName, realArguments);
    }

    /**
     * Getting or creating implementation class instance.
     * We use current substituted class loader for creating class instance. 
     * 
     * @param className
     * @param data
     * @return
     * @throws ClassNotFoundException
     */
    protected Class<?> getImplementationClass(String className)
        throws ClassNotFoundException {
    Class<?> result = null;
    if (result == null) {
        log.info("Creating class instance of " + implClassName);
        result = Class.forName(className);
    }
    return result;
    }

    /**
     * Get or create if necessary implementation instance.
     * 
     * We don't check existence of implementation class instance - because we already checked 
     * it previously ({@link #getMethod}).
     * 
     * @param data
     * @return
     * @throws InstantiationException
     * @throws IllegalAccessException
     */
    protected Object getImplementationInstance() throws InstantiationException,
        IllegalAccessException {
    if (impl == null) {
        log.info("Creating instance of " + implClassName);
        impl = implClass.newInstance();
    }
    return impl;
    }
}
+----------------------------------------------------------------------------------+

