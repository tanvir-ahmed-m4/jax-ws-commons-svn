<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">










<html>
  <head>
    <title>JAX-WS commons - Configuration</title>
    <style type="text/css" media="all">
      @import url("./css/maven-base.css");
      @import url("./css/maven-theme.css");
      @import url("./css/site.css");
    </style>
    <link rel="stylesheet" href="./css/print.css" type="text/css" media="print" />
          <meta name="author" content="Fedor Malyshkin" />
        <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
      </head>
  <body class="composite">
    <!-- TODO: move this into JavaScript to patch the skin
      <div class="xright">      <a href="http://jax-ws.java.net/">JAX-WS</a>
          |
          <a href="http://glassfish.java.net/">Glassfish</a>
      </div>
    -->
    <div id="bodyColumn">
      <div id="contentBox">
        <div class="section"><h2>Configuration</h2>
<dl><dt>Note:</dt>
<dd>This tool could be used only for JAX-WS web-services which was deployed as servlet in a servlet containers.</dd>
</dl>
<p>For use this tool you need to copy beans-generator and <a href="http://asm.objectweb.org" class="externalLink">asm 3.0</a>
 jars into WEB-INF's lib folder and add tools-specific listeners into web.xml. </p>
<div class="source"><pre>&lt;listener&gt;
    &lt;listener-class&gt;org.jvnet.jax_ws_commons.beans_generator.servlet.jaxws.WSServletContextListenerWrapper&lt;/listener-class&gt;
&lt;/listener&gt;


&lt;listener&gt;
    &lt;listener-class&gt;org.jvnet.jax_ws_commons.beans_generator.servlet.jaxws.RequestClassLoaderSubstituter&lt;/listener-class&gt;
&lt;/listener&gt;</pre>
</div>
<p>It releases you from generating web-service artifacts, but configuration process of web application stays the same: you must supply <tt>&quot;sun-jaxws.xml&quot;</tt>
 for JAXWS WS stack.</p>
<p>But you can use additional features like creating your own class which can processes all web-service requests and decides what to with them: invoke a implementator, change request parameters, change response or do something other. For this you must change <tt>&quot;sun-jaxws.xml&quot;</tt>
 like this:</p>
<p>From this:</p>
<div class="source"><pre>&lt;endpoints xmlns=&quot;http://java.sun.com/xml/ns/jax-ws/ri/runtime&quot; version=&quot;2.0&quot;&gt;
    &lt;endpoint name=&quot;Em&quot; implementation=&quot;ru.magnetosoft.magnet.subsystem.context.ContextStaticTest&quot; 
url-pattern=&quot;/Em&quot;  /&gt; 
&lt;/endpoints&gt;</pre>
</div>
<p>to this:</p>
<div class="source"><pre>&lt;endpoints xmlns=&quot;http://java.sun.com/xml/ns/jax-ws/ri/runtime&quot; version=&quot;2.0&quot;&gt;
    &lt;endpoint name=&quot;Em&quot; implementation=&quot;ru.magnetosoft.magnet.subsystem.context.ContextStaticTestNew&quot; 
url-pattern=&quot;/Em&quot;  wrappedClass=&quot;ru.magnetosoft.magnet.subsystem.context.ContextStaticTest&quot; 
implementationInvoker=&quot;ru.magnetosoft.magnet.subsystem.context.invoker.ImplementationInvoker&quot;/&gt; 
&lt;/endpoints&gt;</pre>
</div>
<p>In that case <tt>&quot;implementation&quot;</tt>
 class must differs from <tt>&quot;wrappedClass&quot;</tt>
. It will be generated by the tool and will repeat all methods and annotations of <tt>&quot;wrappedClass&quot;</tt>
 (original class). It packs method name, thrown types, parameter types, parameter values, return type and invokes <tt>&quot;implementationInvoker&quot;</tt>
 with all these datas. After this it waites for result it returns to JAXWS stack. </p>
<p>In our firm we are using this approach in specific manner which described in <a href="usages.html">Usages</a>
.</p>
<p>You must supply your implementator invoker class and it must implements a interface IImplementationInvoker. It gets all parameters in <tt>initialize</tt>
 method and processes all requests with help a <tt>invoke</tt>
 method. Example:</p>
<div class="source"><pre>package org.jvnet.jax_ws_commons.beans_generator.invoker;

import java.io.ByteArrayOutputStream;
import java.io.PrintWriter;
import java.lang.reflect.Method;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.jvnet.jax_ws_commons.beans_generator.conf.IDeploymentConfigurationReader;


/**
 * Class, directly invocable from ambassador.
 * Servers as dispather for all invocations of ws implementator. Simplest realization 
 * could simple invoke implementation, more sophisticated - make a lot of things.
 * 
 * Created: 04.06.2007
 * @author Malyshkin Fedor (fedor.malyshkin@magnetosoft.ru)
 * @version $Revision: 240 $
 */
public class ImplementationInvoker implements IImplementationInvoker {
    private IDeploymentConfigurationReader configReader = null;

    private String implClassName = null;

    private Class implClass = null;

    private Object impl = null;

    private Logger log = null;

    public void initialize(IDeploymentConfigurationReader configReader,
        String implementationClassName) {
    this.configReader = configReader;
    this.implClassName = implementationClassName;
    this.log = Logger.getLogger(implementationClassName);
    }

    public Object invoke(String methodName, Class returnClass,
        Class[] argumentClasses, Class[] thrownTypes, Object returnValue,
        Object[] argumentValues) throws Exception {

    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    PrintWriter pw = new PrintWriter(baos);
    pw.println(&quot;Invoking method: &quot; + methodName);

    pw.println(&quot;&gt;&gt;&gt; args count: &quot; + argumentClasses.length);
    pw.println(&quot;&gt;&gt;&gt; arg classes: &quot;);
    for (Class clazz : argumentClasses)
        pw.print(clazz.getSimpleName() + &quot; &quot;);
    pw.println();

    pw.println(&quot;&gt;&gt;&gt; arg value: &quot;);
    for (Object arg : argumentValues)
        pw.print((arg != null ? arg.toString() : &quot;null&quot;) + &quot; &quot;);
    pw.println();

    pw.println(&quot;&gt;&gt;&gt; return type: &quot; + returnClass.getSimpleName());

    pw.println(&quot;&gt;&gt;&gt; thrown types count: &quot; + thrownTypes.length);
    pw.println(&quot;&gt;&gt;&gt; thrown type classes: &quot;);
    for (Class clazz : thrownTypes)
        pw.print(clazz.getSimpleName() + &quot; &quot;);
    pw.println();

    pw.flush();
    log.info(baos.toString());

    returnValue = invokeImplementation(methodName, returnClass, argumentClasses, thrownTypes, returnValue, argumentValues);

    log.info(&quot;Result: &quot; + (returnValue != null ? returnValue.toString() : &quot;null&quot;));
    return returnValue;
    }

    /**
     * @param methodName
     * @param returnClass
     * @param argumentClasses
     * @param thrownTypes
     * @param returnValue
     * @param argumentValues
     */
    protected Object invokeImplementation(String methodName, Class returnClass,
        Class[] argumentClasses, Class[] thrownTypes, Object returnValue,
        Object[] argumentValues) throws Exception {

    // we create new array of args because we added on additional arg - String
    Class[] realArguments = new Class[argumentClasses.length - 1];
    System.arraycopy(argumentClasses, 0, realArguments, 0, argumentClasses.length - 1);
    Method method = null;

    try {
        method = getMethod(methodName, realArguments);
    } catch (Exception e) {
        log.log(Level.SEVERE, &quot;Exception while getting implementator's method&quot;, e);
    }

    // do the same thing with arg values
    Object[] realArgValues = new Object[argumentValues.length - 1];
    System.arraycopy(argumentValues, 0, realArgValues, 0, argumentClasses.length - 1);
    //try {
    returnValue = method.invoke(getImplementationInstance(), realArgValues);
    //} catch (Exception e) {
    //log.log(Level.SEVERE, &quot;Exception while invoking implementator&quot;, e);
    //}

    return returnValue;
    }

    /**
     * @param methodName
     * @param realArguments
     * @return
     * @throws NoSuchMethodException 
     * @throws SecurityException 
     * @throws ClassNotFoundException 
     */
    protected Method getMethod(String methodName, Class[] realArguments)
        throws SecurityException, NoSuchMethodException,
        ClassNotFoundException {
    if (implClass == null)
        implClass = getImplementationClass(implClassName);
    return implClass.getMethod(methodName, realArguments);
    }

    /**
     * Getting or creating implementation class instance.
     * We use current substituted class loader for creating class instance. 
     * 
     * @param className
     * @param data
     * @return
     * @throws ClassNotFoundException
     */
    protected Class&lt;?&gt; getImplementationClass(String className)
        throws ClassNotFoundException {
    Class&lt;?&gt; result = null;
    if (result == null) {
        log.info(&quot;Creating class instance of &quot; + implClassName);
        result = Class.forName(className);
    }
    return result;
    }

    /**
     * Get or create if necessary implementation instance.
     * 
     * We don't check existence of implementation class instance - because we already checked 
     * it previously ({@link #getMethod}).
     * 
     * @param data
     * @return
     * @throws InstantiationException
     * @throws IllegalAccessException
     */
    protected Object getImplementationInstance() throws InstantiationException,
        IllegalAccessException {
    if (impl == null) {
        log.info(&quot;Creating instance of &quot; + implClassName);
        impl = implClass.newInstance();
    }
    return impl;
    }
}</pre>
</div>
</div>

      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">&#169;  
          2008
    
          
  

  
  
  &nbsp;| Last Published: 05/24/2008
  &nbsp;| Version: 1.0-SNAPSHOT
</div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
